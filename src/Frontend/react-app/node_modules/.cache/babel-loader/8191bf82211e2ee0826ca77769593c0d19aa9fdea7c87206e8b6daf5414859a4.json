{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport * as React from 'react';\nimport useForkRef from '@mui/utils/useForkRef';\nimport useEventCallback from '@mui/utils/useEventCallback';\nimport useEnhancedEffect from '@mui/utils/useEnhancedEffect';\nimport { parseSelectedSections } from \"./useField.utils.js\";\nimport { getActiveElement } from \"../../utils/utils.js\";\nimport { useSplitFieldProps } from \"../../../hooks/index.js\";\nimport { useFieldCharacterEditing } from \"./useFieldCharacterEditing.js\";\nimport { useFieldState } from \"./useFieldState.js\";\nimport { useFieldInternalPropsWithDefaults } from \"./useFieldInternalPropsWithDefaults.js\";\nimport { syncSelectionToDOM } from \"./syncSelectionToDOM.js\";\nimport { useFieldRootProps } from \"./useFieldRootProps.js\";\nimport { useFieldHiddenInputProps } from \"./useFieldHiddenInputProps.js\";\nimport { useFieldSectionContainerProps } from \"./useFieldSectionContainerProps.js\";\nimport { useFieldSectionContentProps } from \"./useFieldSectionContentProps.js\";\nexport const useFieldV7TextField = parameters => {\n  const {\n    props,\n    manager,\n    skipContextFieldRefAssignment,\n    manager: {\n      valueType,\n      internal_useOpenPickerButtonAriaLabel: useOpenPickerButtonAriaLabel\n    }\n  } = parameters;\n  const {\n    internalProps,\n    forwardedProps\n  } = useSplitFieldProps(props, valueType);\n  const internalPropsWithDefaults = useFieldInternalPropsWithDefaults({\n    manager,\n    internalProps,\n    skipContextFieldRefAssignment\n  });\n  const {\n    sectionListRef: sectionListRefProp,\n    onBlur,\n    onClick,\n    onFocus,\n    onInput,\n    onPaste,\n    onKeyDown,\n    onClear,\n    clearable\n  } = forwardedProps;\n  const {\n    disabled = false,\n    readOnly = false,\n    autoFocus = false,\n    focused: focusedProp,\n    unstableFieldRef\n  } = internalPropsWithDefaults;\n  const sectionListRef = React.useRef(null);\n  const handleSectionListRef = useForkRef(sectionListRefProp, sectionListRef);\n  const domGetters = React.useMemo(() => ({\n    isReady: () => sectionListRef.current != null,\n    getRoot: () => sectionListRef.current.getRoot(),\n    getSectionContainer: sectionIndex => sectionListRef.current.getSectionContainer(sectionIndex),\n    getSectionContent: sectionIndex => sectionListRef.current.getSectionContent(sectionIndex),\n    getSectionIndexFromDOMElement: element => sectionListRef.current.getSectionIndexFromDOMElement(element)\n  }), [sectionListRef]);\n  const stateResponse = useFieldState({\n    manager,\n    internalPropsWithDefaults,\n    forwardedProps\n  });\n  const {\n    // States and derived states\n    areAllSectionsEmpty,\n    error,\n    parsedSelectedSections,\n    sectionOrder,\n    state,\n    value,\n    // Methods to update the states\n    clearValue,\n    setSelectedSections\n  } = stateResponse;\n  const applyCharacterEditing = useFieldCharacterEditing({\n    stateResponse\n  });\n  const openPickerAriaLabel = useOpenPickerButtonAriaLabel(value);\n  const [focused, setFocused] = React.useState(false);\n  function focusField(newSelectedSections = 0) {\n    if (disabled || !sectionListRef.current ||\n    // if the field is already focused, we don't need to focus it again\n    getActiveSectionIndex(sectionListRef) != null) {\n      return;\n    }\n    const newParsedSelectedSections = parseSelectedSections(newSelectedSections, state.sections);\n    setFocused(true);\n    sectionListRef.current.getSectionContent(newParsedSelectedSections).focus();\n  }\n  const rootProps = useFieldRootProps({\n    manager,\n    internalPropsWithDefaults,\n    stateResponse,\n    applyCharacterEditing,\n    focused,\n    setFocused,\n    domGetters\n  });\n  const hiddenInputProps = useFieldHiddenInputProps({\n    manager,\n    stateResponse\n  });\n  const createSectionContainerProps = useFieldSectionContainerProps({\n    stateResponse,\n    internalPropsWithDefaults\n  });\n  const createSectionContentProps = useFieldSectionContentProps({\n    manager,\n    stateResponse,\n    applyCharacterEditing,\n    internalPropsWithDefaults,\n    domGetters,\n    focused\n  });\n  const handleRootKeyDown = useEventCallback(event => {\n    onKeyDown?.(event);\n    rootProps.onKeyDown(event);\n  });\n  const handleRootBlur = useEventCallback(event => {\n    onBlur?.(event);\n    rootProps.onBlur(event);\n  });\n  const handleRootFocus = useEventCallback(event => {\n    onFocus?.(event);\n    rootProps.onFocus(event);\n  });\n  const handleRootClick = useEventCallback(event => {\n    // The click event on the clear or open button would propagate to the input, trigger this handler and result in an inadvertent section selection.\n    // We avoid this by checking if the call of `handleInputClick` is actually intended, or a propagated call, which should be skipped.\n    if (event.isDefaultPrevented()) {\n      return;\n    }\n    onClick?.(event);\n    rootProps.onClick(event);\n  });\n  const handleRootPaste = useEventCallback(event => {\n    onPaste?.(event);\n    rootProps.onPaste(event);\n  });\n  const handleRootInput = useEventCallback(event => {\n    onInput?.(event);\n    rootProps.onInput(event);\n  });\n  const handleClear = useEventCallback((event, ...args) => {\n    event.preventDefault();\n    onClear?.(event, ...args);\n    clearValue();\n    if (!isFieldFocused(sectionListRef)) {\n      // setSelectedSections is called internally\n      focusField(0);\n    } else {\n      setSelectedSections(sectionOrder.startIndex);\n    }\n  });\n  const elements = React.useMemo(() => {\n    return state.sections.map((section, sectionIndex) => {\n      const content = createSectionContentProps(section, sectionIndex);\n      return {\n        container: createSectionContainerProps(sectionIndex),\n        content: createSectionContentProps(section, sectionIndex),\n        before: {\n          children: section.startSeparator\n        },\n        after: {\n          children: section.endSeparator,\n          'data-range-position': section.isEndFormatSeparator ? content['data-range-position'] : undefined\n        }\n      };\n    });\n  }, [state.sections, createSectionContainerProps, createSectionContentProps]);\n  React.useEffect(() => {\n    if (sectionListRef.current == null) {\n      throw new Error(['MUI X: The `sectionListRef` prop has not been initialized by `PickersSectionList`', 'You probably tried to pass a component to the `textField` slot that contains an `<input />` element instead of a `PickersSectionList`.', '', 'If you want to keep using an `<input />` HTML element for the editing, please add the `enableAccessibleFieldDOMStructure={false}` prop to your Picker or Field component:', '', '<DatePicker enableAccessibleFieldDOMStructure={false} slots={{ textField: MyCustomTextField }} />', '', 'Learn more about the field accessible DOM structure on the MUI documentation: https://mui.com/x/react-date-pickers/fields/#fields-to-edit-a-single-element'].join('\\n'));\n    }\n    if (autoFocus && !disabled && sectionListRef.current) {\n      sectionListRef.current.getSectionContent(sectionOrder.startIndex).focus();\n    }\n  }, []); // eslint-disable-line react-hooks/exhaustive-deps\n\n  useEnhancedEffect(() => {\n    if (!focused || !sectionListRef.current) {\n      return;\n    }\n    if (parsedSelectedSections === 'all') {\n      sectionListRef.current.getRoot().focus();\n    } else if (typeof parsedSelectedSections === 'number') {\n      const domElement = sectionListRef.current.getSectionContent(parsedSelectedSections);\n      if (domElement) {\n        domElement.focus();\n      }\n    }\n  }, [parsedSelectedSections, focused]);\n  useEnhancedEffect(() => {\n    syncSelectionToDOM({\n      focused,\n      domGetters,\n      stateResponse\n    });\n  });\n  React.useImperativeHandle(unstableFieldRef, () => ({\n    getSections: () => state.sections,\n    getActiveSectionIndex: () => getActiveSectionIndex(sectionListRef),\n    setSelectedSections: newSelectedSections => {\n      if (disabled || !sectionListRef.current) {\n        return;\n      }\n      const newParsedSelectedSections = parseSelectedSections(newSelectedSections, state.sections);\n      const newActiveSectionIndex = newParsedSelectedSections === 'all' ? 0 : newParsedSelectedSections;\n      setFocused(newActiveSectionIndex !== null);\n      setSelectedSections(newSelectedSections);\n    },\n    focusField,\n    isFieldFocused: () => isFieldFocused(sectionListRef)\n  }));\n  return _extends({}, forwardedProps, rootProps, {\n    onBlur: handleRootBlur,\n    onClick: handleRootClick,\n    onFocus: handleRootFocus,\n    onInput: handleRootInput,\n    onPaste: handleRootPaste,\n    onKeyDown: handleRootKeyDown,\n    onClear: handleClear\n  }, hiddenInputProps, {\n    error,\n    clearable: Boolean(clearable && !areAllSectionsEmpty && !readOnly && !disabled),\n    focused: focusedProp ?? focused,\n    sectionListRef: handleSectionListRef,\n    // Additional\n    enableAccessibleFieldDOMStructure: true,\n    elements,\n    areAllSectionsEmpty,\n    disabled,\n    readOnly,\n    autoFocus,\n    openPickerAriaLabel\n  });\n};\nfunction getActiveSectionIndex(sectionListRef) {\n  const activeElement = getActiveElement(document);\n  if (!activeElement || !sectionListRef.current || !sectionListRef.current.getRoot().contains(activeElement)) {\n    return null;\n  }\n  return sectionListRef.current.getSectionIndexFromDOMElement(activeElement);\n}\nfunction isFieldFocused(sectionListRef) {\n  const activeElement = getActiveElement(document);\n  return !!sectionListRef.current && sectionListRef.current.getRoot().contains(activeElement);\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}