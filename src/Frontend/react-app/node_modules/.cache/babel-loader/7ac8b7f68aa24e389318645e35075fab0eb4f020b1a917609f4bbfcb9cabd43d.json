{"ast":null,"code":"(function (root) {\n  'use strict';\n\n  // A list of regular expressions that match arbitrary IPv4 addresses,\n  // for which a number of weird notations exist.\n  // Note that an address like 0010.0xa5.1.1 is considered legal.\n  const ipv4Part = '(0?\\\\d+|0x[a-f0-9]+)';\n  const ipv4Regexes = {\n    fourOctet: new RegExp(`^${ipv4Part}\\\\.${ipv4Part}\\\\.${ipv4Part}\\\\.${ipv4Part}$`, 'i'),\n    threeOctet: new RegExp(`^${ipv4Part}\\\\.${ipv4Part}\\\\.${ipv4Part}$`, 'i'),\n    twoOctet: new RegExp(`^${ipv4Part}\\\\.${ipv4Part}$`, 'i'),\n    longValue: new RegExp(`^${ipv4Part}$`, 'i')\n  };\n\n  // Regular Expression for checking Octal numbers\n  const octalRegex = new RegExp(`^0[0-7]+$`, 'i');\n  const hexRegex = new RegExp(`^0x[a-f0-9]+$`, 'i');\n  const zoneIndex = '%[0-9a-z]{1,}';\n\n  // IPv6-matching regular expressions.\n  // For IPv6, the task is simpler: it is enough to match the colon-delimited\n  // hexadecimal IPv6 and a transitional variant with dotted-decimal IPv4 at\n  // the end.\n  const ipv6Part = '(?:[0-9a-f]+::?)+';\n  const ipv6Regexes = {\n    zoneIndex: new RegExp(zoneIndex, 'i'),\n    'native': new RegExp(`^(::)?(${ipv6Part})?([0-9a-f]+)?(::)?(${zoneIndex})?$`, 'i'),\n    deprecatedTransitional: new RegExp(`^(?:::)(${ipv4Part}\\\\.${ipv4Part}\\\\.${ipv4Part}\\\\.${ipv4Part}(${zoneIndex})?)$`, 'i'),\n    transitional: new RegExp(`^((?:${ipv6Part})|(?:::)(?:${ipv6Part})?)${ipv4Part}\\\\.${ipv4Part}\\\\.${ipv4Part}\\\\.${ipv4Part}(${zoneIndex})?$`, 'i')\n  };\n\n  // Expand :: in an IPv6 address or address part consisting of `parts` groups.\n  function expandIPv6(string, parts) {\n    // More than one '::' means invalid adddress\n    if (string.indexOf('::') !== string.lastIndexOf('::')) {\n      return null;\n    }\n    let colonCount = 0;\n    let lastColon = -1;\n    let zoneId = (string.match(ipv6Regexes.zoneIndex) || [])[0];\n    let replacement, replacementCount;\n\n    // Remove zone index and save it for later\n    if (zoneId) {\n      zoneId = zoneId.substring(1);\n      string = string.replace(/%.+$/, '');\n    }\n\n    // How many parts do we already have?\n    while ((lastColon = string.indexOf(':', lastColon + 1)) >= 0) {\n      colonCount++;\n    }\n\n    // 0::0 is two parts more than ::\n    if (string.substr(0, 2) === '::') {\n      colonCount--;\n    }\n    if (string.substr(-2, 2) === '::') {\n      colonCount--;\n    }\n\n    // The following loop would hang if colonCount > parts\n    if (colonCount > parts) {\n      return null;\n    }\n\n    // replacement = ':' + '0:' * (parts - colonCount)\n    replacementCount = parts - colonCount;\n    replacement = ':';\n    while (replacementCount--) {\n      replacement += '0:';\n    }\n\n    // Insert the missing zeroes\n    string = string.replace('::', replacement);\n\n    // Trim any garbage which may be hanging around if :: was at the edge in\n    // the source strin\n    if (string[0] === ':') {\n      string = string.slice(1);\n    }\n    if (string[string.length - 1] === ':') {\n      string = string.slice(0, -1);\n    }\n    parts = function () {\n      const ref = string.split(':');\n      const results = [];\n      for (let i = 0; i < ref.length; i++) {\n        results.push(parseInt(ref[i], 16));\n      }\n      return results;\n    }();\n    return {\n      parts: parts,\n      zoneId: zoneId\n    };\n  }\n\n  // A generic CIDR (Classless Inter-Domain Routing) RFC1518 range matcher.\n  function matchCIDR(first, second, partSize, cidrBits) {\n    if (first.length !== second.length) {\n      throw new Error('ipaddr: cannot match CIDR for objects with different lengths');\n    }\n    let part = 0;\n    let shift;\n    while (cidrBits > 0) {\n      shift = partSize - cidrBits;\n      if (shift < 0) {\n        shift = 0;\n      }\n      if (first[part] >> shift !== second[part] >> shift) {\n        return false;\n      }\n      cidrBits -= partSize;\n      part += 1;\n    }\n    return true;\n  }\n  function parseIntAuto(string) {\n    // Hexadedimal base 16 (0x#)\n    if (hexRegex.test(string)) {\n      return parseInt(string, 16);\n    }\n    // While octal representation is discouraged by ECMAScript 3\n    // and forbidden by ECMAScript 5, we silently allow it to\n    // work only if the rest of the string has numbers less than 8.\n    if (string[0] === '0' && !isNaN(parseInt(string[1], 10))) {\n      if (octalRegex.test(string)) {\n        return parseInt(string, 8);\n      }\n      throw new Error(`ipaddr: cannot parse ${string} as octal`);\n    }\n    // Always include the base 10 radix!\n    return parseInt(string, 10);\n  }\n  function padPart(part, length) {\n    while (part.length < length) {\n      part = `0${part}`;\n    }\n    return part;\n  }\n  const ipaddr = {};\n\n  // An IPv4 address (RFC791).\n  ipaddr.IPv4 = function () {\n    // Constructs a new IPv4 address from an array of four octets\n    // in network order (MSB first)\n    // Verifies the input.\n    function IPv4(octets) {\n      if (octets.length !== 4) {\n        throw new Error('ipaddr: ipv4 octet count should be 4');\n      }\n      let i, octet;\n      for (i = 0; i < octets.length; i++) {\n        octet = octets[i];\n        if (!(0 <= octet && octet <= 255)) {\n          throw new Error('ipaddr: ipv4 octet should fit in 8 bits');\n        }\n      }\n      this.octets = octets;\n    }\n\n    // Special IPv4 address ranges.\n    // See also https://en.wikipedia.org/wiki/Reserved_IP_addresses\n    IPv4.prototype.SpecialRanges = {\n      unspecified: [[new IPv4([0, 0, 0, 0]), 8]],\n      broadcast: [[new IPv4([255, 255, 255, 255]), 32]],\n      // RFC3171\n      multicast: [[new IPv4([224, 0, 0, 0]), 4]],\n      // RFC3927\n      linkLocal: [[new IPv4([169, 254, 0, 0]), 16]],\n      // RFC5735\n      loopback: [[new IPv4([127, 0, 0, 0]), 8]],\n      // RFC6598\n      carrierGradeNat: [[new IPv4([100, 64, 0, 0]), 10]],\n      // RFC1918\n      'private': [[new IPv4([10, 0, 0, 0]), 8], [new IPv4([172, 16, 0, 0]), 12], [new IPv4([192, 168, 0, 0]), 16]],\n      // Reserved and testing-only ranges; RFCs 5735, 5737, 2544, 1700\n      reserved: [[new IPv4([192, 0, 0, 0]), 24], [new IPv4([192, 0, 2, 0]), 24], [new IPv4([192, 88, 99, 0]), 24], [new IPv4([198, 18, 0, 0]), 15], [new IPv4([198, 51, 100, 0]), 24], [new IPv4([203, 0, 113, 0]), 24], [new IPv4([240, 0, 0, 0]), 4]],\n      // RFC7534, RFC7535\n      as112: [[new IPv4([192, 175, 48, 0]), 24], [new IPv4([192, 31, 196, 0]), 24]],\n      // RFC7450\n      amt: [[new IPv4([192, 52, 193, 0]), 24]]\n    };\n\n    // The 'kind' method exists on both IPv4 and IPv6 classes.\n    IPv4.prototype.kind = function () {\n      return 'ipv4';\n    };\n\n    // Checks if this address matches other one within given CIDR range.\n    IPv4.prototype.match = function (other, cidrRange) {\n      let ref;\n      if (cidrRange === undefined) {\n        ref = other;\n        other = ref[0];\n        cidrRange = ref[1];\n      }\n      if (other.kind() !== 'ipv4') {\n        throw new Error('ipaddr: cannot match ipv4 address with non-ipv4 one');\n      }\n      return matchCIDR(this.octets, other.octets, 8, cidrRange);\n    };\n\n    // returns a number of leading ones in IPv4 address, making sure that\n    // the rest is a solid sequence of 0's (valid netmask)\n    // returns either the CIDR length or null if mask is not valid\n    IPv4.prototype.prefixLengthFromSubnetMask = function () {\n      let cidr = 0;\n      // non-zero encountered stop scanning for zeroes\n      let stop = false;\n      // number of zeroes in octet\n      const zerotable = {\n        0: 8,\n        128: 7,\n        192: 6,\n        224: 5,\n        240: 4,\n        248: 3,\n        252: 2,\n        254: 1,\n        255: 0\n      };\n      let i, octet, zeros;\n      for (i = 3; i >= 0; i -= 1) {\n        octet = this.octets[i];\n        if (octet in zerotable) {\n          zeros = zerotable[octet];\n          if (stop && zeros !== 0) {\n            return null;\n          }\n          if (zeros !== 8) {\n            stop = true;\n          }\n          cidr += zeros;\n        } else {\n          return null;\n        }\n      }\n      return 32 - cidr;\n    };\n\n    // Checks if the address corresponds to one of the special ranges.\n    IPv4.prototype.range = function () {\n      return ipaddr.subnetMatch(this, this.SpecialRanges);\n    };\n\n    // Returns an array of byte-sized values in network order (MSB first)\n    IPv4.prototype.toByteArray = function () {\n      return this.octets.slice(0);\n    };\n\n    // Converts this IPv4 address to an IPv4-mapped IPv6 address.\n    IPv4.prototype.toIPv4MappedAddress = function () {\n      return ipaddr.IPv6.parse(`::ffff:${this.toString()}`);\n    };\n\n    // Symmetrical method strictly for aligning with the IPv6 methods.\n    IPv4.prototype.toNormalizedString = function () {\n      return this.toString();\n    };\n\n    // Returns the address in convenient, decimal-dotted format.\n    IPv4.prototype.toString = function () {\n      return this.octets.join('.');\n    };\n    return IPv4;\n  }();\n\n  // A utility function to return broadcast address given the IPv4 interface and prefix length in CIDR notation\n  ipaddr.IPv4.broadcastAddressFromCIDR = function (string) {\n    try {\n      const cidr = this.parseCIDR(string);\n      const ipInterfaceOctets = cidr[0].toByteArray();\n      const subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();\n      const octets = [];\n      let i = 0;\n      while (i < 4) {\n        // Broadcast address is bitwise OR between ip interface and inverted mask\n        octets.push(parseInt(ipInterfaceOctets[i], 10) | parseInt(subnetMaskOctets[i], 10) ^ 255);\n        i++;\n      }\n      return new this(octets);\n    } catch (e) {\n      throw new Error('ipaddr: the address does not have IPv4 CIDR format');\n    }\n  };\n\n  // Checks if a given string is formatted like IPv4 address.\n  ipaddr.IPv4.isIPv4 = function (string) {\n    return this.parser(string) !== null;\n  };\n\n  // Checks if a given string is a valid IPv4 address.\n  ipaddr.IPv4.isValid = function (string) {\n    try {\n      new this(this.parser(string));\n      return true;\n    } catch (e) {\n      return false;\n    }\n  };\n\n  // Checks if a given string is a valid IPv4 address in CIDR notation.\n  ipaddr.IPv4.isValidCIDR = function (string) {\n    try {\n      this.parseCIDR(string);\n      return true;\n    } catch (e) {\n      return false;\n    }\n  };\n\n  // Checks if a given string is a full four-part IPv4 Address.\n  ipaddr.IPv4.isValidFourPartDecimal = function (string) {\n    if (ipaddr.IPv4.isValid(string) && string.match(/^(0|[1-9]\\d*)(\\.(0|[1-9]\\d*)){3}$/)) {\n      return true;\n    } else {\n      return false;\n    }\n  };\n\n  // A utility function to return network address given the IPv4 interface and prefix length in CIDR notation\n  ipaddr.IPv4.networkAddressFromCIDR = function (string) {\n    let cidr, i, ipInterfaceOctets, octets, subnetMaskOctets;\n    try {\n      cidr = this.parseCIDR(string);\n      ipInterfaceOctets = cidr[0].toByteArray();\n      subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();\n      octets = [];\n      i = 0;\n      while (i < 4) {\n        // Network address is bitwise AND between ip interface and mask\n        octets.push(parseInt(ipInterfaceOctets[i], 10) & parseInt(subnetMaskOctets[i], 10));\n        i++;\n      }\n      return new this(octets);\n    } catch (e) {\n      throw new Error('ipaddr: the address does not have IPv4 CIDR format');\n    }\n  };\n\n  // Tries to parse and validate a string with IPv4 address.\n  // Throws an error if it fails.\n  ipaddr.IPv4.parse = function (string) {\n    const parts = this.parser(string);\n    if (parts === null) {\n      throw new Error('ipaddr: string is not formatted like an IPv4 Address');\n    }\n    return new this(parts);\n  };\n\n  // Parses the string as an IPv4 Address with CIDR Notation.\n  ipaddr.IPv4.parseCIDR = function (string) {\n    let match;\n    if (match = string.match(/^(.+)\\/(\\d+)$/)) {\n      const maskLength = parseInt(match[2]);\n      if (maskLength >= 0 && maskLength <= 32) {\n        const parsed = [this.parse(match[1]), maskLength];\n        Object.defineProperty(parsed, 'toString', {\n          value: function () {\n            return this.join('/');\n          }\n        });\n        return parsed;\n      }\n    }\n    throw new Error('ipaddr: string is not formatted like an IPv4 CIDR range');\n  };\n\n  // Classful variants (like a.b, where a is an octet, and b is a 24-bit\n  // value representing last three octets; this corresponds to a class C\n  // address) are omitted due to classless nature of modern Internet.\n  ipaddr.IPv4.parser = function (string) {\n    let match, part, value;\n\n    // parseInt recognizes all that octal & hexadecimal weirdness for us\n    if (match = string.match(ipv4Regexes.fourOctet)) {\n      return function () {\n        const ref = match.slice(1, 6);\n        const results = [];\n        for (let i = 0; i < ref.length; i++) {\n          part = ref[i];\n          results.push(parseIntAuto(part));\n        }\n        return results;\n      }();\n    } else if (match = string.match(ipv4Regexes.longValue)) {\n      value = parseIntAuto(match[1]);\n      if (value > 0xffffffff || value < 0) {\n        throw new Error('ipaddr: address outside defined range');\n      }\n      return function () {\n        const results = [];\n        let shift;\n        for (shift = 0; shift <= 24; shift += 8) {\n          results.push(value >> shift & 0xff);\n        }\n        return results;\n      }().reverse();\n    } else if (match = string.match(ipv4Regexes.twoOctet)) {\n      return function () {\n        const ref = match.slice(1, 4);\n        const results = [];\n        value = parseIntAuto(ref[1]);\n        if (value > 0xffffff || value < 0) {\n          throw new Error('ipaddr: address outside defined range');\n        }\n        results.push(parseIntAuto(ref[0]));\n        results.push(value >> 16 & 0xff);\n        results.push(value >> 8 & 0xff);\n        results.push(value & 0xff);\n        return results;\n      }();\n    } else if (match = string.match(ipv4Regexes.threeOctet)) {\n      return function () {\n        const ref = match.slice(1, 5);\n        const results = [];\n        value = parseIntAuto(ref[2]);\n        if (value > 0xffff || value < 0) {\n          throw new Error('ipaddr: address outside defined range');\n        }\n        results.push(parseIntAuto(ref[0]));\n        results.push(parseIntAuto(ref[1]));\n        results.push(value >> 8 & 0xff);\n        results.push(value & 0xff);\n        return results;\n      }();\n    } else {\n      return null;\n    }\n  };\n\n  // A utility function to return subnet mask in IPv4 format given the prefix length\n  ipaddr.IPv4.subnetMaskFromPrefixLength = function (prefix) {\n    prefix = parseInt(prefix);\n    if (prefix < 0 || prefix > 32) {\n      throw new Error('ipaddr: invalid IPv4 prefix length');\n    }\n    const octets = [0, 0, 0, 0];\n    let j = 0;\n    const filledOctetCount = Math.floor(prefix / 8);\n    while (j < filledOctetCount) {\n      octets[j] = 255;\n      j++;\n    }\n    if (filledOctetCount < 4) {\n      octets[filledOctetCount] = Math.pow(2, prefix % 8) - 1 << 8 - prefix % 8;\n    }\n    return new this(octets);\n  };\n\n  // An IPv6 address (RFC2460)\n  ipaddr.IPv6 = function () {\n    // Constructs an IPv6 address from an array of eight 16 - bit parts\n    // or sixteen 8 - bit parts in network order(MSB first).\n    // Throws an error if the input is invalid.\n    function IPv6(parts, zoneId) {\n      let i, part;\n      if (parts.length === 16) {\n        this.parts = [];\n        for (i = 0; i <= 14; i += 2) {\n          this.parts.push(parts[i] << 8 | parts[i + 1]);\n        }\n      } else if (parts.length === 8) {\n        this.parts = parts;\n      } else {\n        throw new Error('ipaddr: ipv6 part count should be 8 or 16');\n      }\n      for (i = 0; i < this.parts.length; i++) {\n        part = this.parts[i];\n        if (!(0 <= part && part <= 0xffff)) {\n          throw new Error('ipaddr: ipv6 part should fit in 16 bits');\n        }\n      }\n      if (zoneId) {\n        this.zoneId = zoneId;\n      }\n    }\n\n    // Special IPv6 ranges\n    IPv6.prototype.SpecialRanges = {\n      // RFC4291, here and after\n      unspecified: [new IPv6([0, 0, 0, 0, 0, 0, 0, 0]), 128],\n      linkLocal: [new IPv6([0xfe80, 0, 0, 0, 0, 0, 0, 0]), 10],\n      multicast: [new IPv6([0xff00, 0, 0, 0, 0, 0, 0, 0]), 8],\n      loopback: [new IPv6([0, 0, 0, 0, 0, 0, 0, 1]), 128],\n      uniqueLocal: [new IPv6([0xfc00, 0, 0, 0, 0, 0, 0, 0]), 7],\n      ipv4Mapped: [new IPv6([0, 0, 0, 0, 0, 0xffff, 0, 0]), 96],\n      // RFC6666\n      discard: [new IPv6([0x100, 0, 0, 0, 0, 0, 0, 0]), 64],\n      // RFC6145\n      rfc6145: [new IPv6([0, 0, 0, 0, 0xffff, 0, 0, 0]), 96],\n      // RFC6052\n      rfc6052: [new IPv6([0x64, 0xff9b, 0, 0, 0, 0, 0, 0]), 96],\n      // RFC3056\n      '6to4': [new IPv6([0x2002, 0, 0, 0, 0, 0, 0, 0]), 16],\n      // RFC6052, RFC6146\n      teredo: [new IPv6([0x2001, 0, 0, 0, 0, 0, 0, 0]), 32],\n      // RFC5180\n      benchmarking: [new IPv6([0x2001, 0x2, 0, 0, 0, 0, 0, 0]), 48],\n      // RFC7450\n      amt: [new IPv6([0x2001, 0x3, 0, 0, 0, 0, 0, 0]), 32],\n      as112v6: [[new IPv6([0x2001, 0x4, 0x112, 0, 0, 0, 0, 0]), 48], [new IPv6([0x2620, 0x4f, 0x8000, 0, 0, 0, 0, 0]), 48]],\n      deprecated: [new IPv6([0x2001, 0x10, 0, 0, 0, 0, 0, 0]), 28],\n      orchid2: [new IPv6([0x2001, 0x20, 0, 0, 0, 0, 0, 0]), 28],\n      droneRemoteIdProtocolEntityTags: [new IPv6([0x2001, 0x30, 0, 0, 0, 0, 0, 0]), 28],\n      reserved: [\n      // RFC3849\n      [new IPv6([0x2001, 0, 0, 0, 0, 0, 0, 0]), 23],\n      // RFC2928\n      [new IPv6([0x2001, 0xdb8, 0, 0, 0, 0, 0, 0]), 32]]\n    };\n\n    // Checks if this address is an IPv4-mapped IPv6 address.\n    IPv6.prototype.isIPv4MappedAddress = function () {\n      return this.range() === 'ipv4Mapped';\n    };\n\n    // The 'kind' method exists on both IPv4 and IPv6 classes.\n    IPv6.prototype.kind = function () {\n      return 'ipv6';\n    };\n\n    // Checks if this address matches other one within given CIDR range.\n    IPv6.prototype.match = function (other, cidrRange) {\n      let ref;\n      if (cidrRange === undefined) {\n        ref = other;\n        other = ref[0];\n        cidrRange = ref[1];\n      }\n      if (other.kind() !== 'ipv6') {\n        throw new Error('ipaddr: cannot match ipv6 address with non-ipv6 one');\n      }\n      return matchCIDR(this.parts, other.parts, 16, cidrRange);\n    };\n\n    // returns a number of leading ones in IPv6 address, making sure that\n    // the rest is a solid sequence of 0's (valid netmask)\n    // returns either the CIDR length or null if mask is not valid\n    IPv6.prototype.prefixLengthFromSubnetMask = function () {\n      let cidr = 0;\n      // non-zero encountered stop scanning for zeroes\n      let stop = false;\n      // number of zeroes in octet\n      const zerotable = {\n        0: 16,\n        32768: 15,\n        49152: 14,\n        57344: 13,\n        61440: 12,\n        63488: 11,\n        64512: 10,\n        65024: 9,\n        65280: 8,\n        65408: 7,\n        65472: 6,\n        65504: 5,\n        65520: 4,\n        65528: 3,\n        65532: 2,\n        65534: 1,\n        65535: 0\n      };\n      let part, zeros;\n      for (let i = 7; i >= 0; i -= 1) {\n        part = this.parts[i];\n        if (part in zerotable) {\n          zeros = zerotable[part];\n          if (stop && zeros !== 0) {\n            return null;\n          }\n          if (zeros !== 16) {\n            stop = true;\n          }\n          cidr += zeros;\n        } else {\n          return null;\n        }\n      }\n      return 128 - cidr;\n    };\n\n    // Checks if the address corresponds to one of the special ranges.\n    IPv6.prototype.range = function () {\n      return ipaddr.subnetMatch(this, this.SpecialRanges);\n    };\n\n    // Returns an array of byte-sized values in network order (MSB first)\n    IPv6.prototype.toByteArray = function () {\n      let part;\n      const bytes = [];\n      const ref = this.parts;\n      for (let i = 0; i < ref.length; i++) {\n        part = ref[i];\n        bytes.push(part >> 8);\n        bytes.push(part & 0xff);\n      }\n      return bytes;\n    };\n\n    // Returns the address in expanded format with all zeroes included, like\n    // 2001:0db8:0008:0066:0000:0000:0000:0001\n    IPv6.prototype.toFixedLengthString = function () {\n      const addr = function () {\n        const results = [];\n        for (let i = 0; i < this.parts.length; i++) {\n          results.push(padPart(this.parts[i].toString(16), 4));\n        }\n        return results;\n      }.call(this).join(':');\n      let suffix = '';\n      if (this.zoneId) {\n        suffix = `%${this.zoneId}`;\n      }\n      return addr + suffix;\n    };\n\n    // Converts this address to IPv4 address if it is an IPv4-mapped IPv6 address.\n    // Throws an error otherwise.\n    IPv6.prototype.toIPv4Address = function () {\n      if (!this.isIPv4MappedAddress()) {\n        throw new Error('ipaddr: trying to convert a generic ipv6 address to ipv4');\n      }\n      const ref = this.parts.slice(-2);\n      const high = ref[0];\n      const low = ref[1];\n      return new ipaddr.IPv4([high >> 8, high & 0xff, low >> 8, low & 0xff]);\n    };\n\n    // Returns the address in expanded format with all zeroes included, like\n    // 2001:db8:8:66:0:0:0:1\n    //\n    // Deprecated: use toFixedLengthString() instead.\n    IPv6.prototype.toNormalizedString = function () {\n      const addr = function () {\n        const results = [];\n        for (let i = 0; i < this.parts.length; i++) {\n          results.push(this.parts[i].toString(16));\n        }\n        return results;\n      }.call(this).join(':');\n      let suffix = '';\n      if (this.zoneId) {\n        suffix = `%${this.zoneId}`;\n      }\n      return addr + suffix;\n    };\n\n    // Returns the address in compact, human-readable format like\n    // 2001:db8:8:66::1\n    // in line with RFC 5952 (see https://tools.ietf.org/html/rfc5952#section-4)\n    IPv6.prototype.toRFC5952String = function () {\n      const regex = /((^|:)(0(:|$)){2,})/g;\n      const string = this.toNormalizedString();\n      let bestMatchIndex = 0;\n      let bestMatchLength = -1;\n      let match;\n      while (match = regex.exec(string)) {\n        if (match[0].length > bestMatchLength) {\n          bestMatchIndex = match.index;\n          bestMatchLength = match[0].length;\n        }\n      }\n      if (bestMatchLength < 0) {\n        return string;\n      }\n      return `${string.substring(0, bestMatchIndex)}::${string.substring(bestMatchIndex + bestMatchLength)}`;\n    };\n\n    // Returns the address in compact, human-readable format like\n    // 2001:db8:8:66::1\n    // Calls toRFC5952String under the hood.\n    IPv6.prototype.toString = function () {\n      return this.toRFC5952String();\n    };\n    return IPv6;\n  }();\n\n  // A utility function to return broadcast address given the IPv6 interface and prefix length in CIDR notation\n  ipaddr.IPv6.broadcastAddressFromCIDR = function (string) {\n    try {\n      const cidr = this.parseCIDR(string);\n      const ipInterfaceOctets = cidr[0].toByteArray();\n      const subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();\n      const octets = [];\n      let i = 0;\n      while (i < 16) {\n        // Broadcast address is bitwise OR between ip interface and inverted mask\n        octets.push(parseInt(ipInterfaceOctets[i], 10) | parseInt(subnetMaskOctets[i], 10) ^ 255);\n        i++;\n      }\n      return new this(octets);\n    } catch (e) {\n      throw new Error(`ipaddr: the address does not have IPv6 CIDR format (${e})`);\n    }\n  };\n\n  // Checks if a given string is formatted like IPv6 address.\n  ipaddr.IPv6.isIPv6 = function (string) {\n    return this.parser(string) !== null;\n  };\n\n  // Checks to see if string is a valid IPv6 Address\n  ipaddr.IPv6.isValid = function (string) {\n    // Since IPv6.isValid is always called first, this shortcut\n    // provides a substantial performance gain.\n    if (typeof string === 'string' && string.indexOf(':') === -1) {\n      return false;\n    }\n    try {\n      const addr = this.parser(string);\n      new this(addr.parts, addr.zoneId);\n      return true;\n    } catch (e) {\n      return false;\n    }\n  };\n\n  // Checks if a given string is a valid IPv6 address in CIDR notation.\n  ipaddr.IPv6.isValidCIDR = function (string) {\n    // See note in IPv6.isValid\n    if (typeof string === 'string' && string.indexOf(':') === -1) {\n      return false;\n    }\n    try {\n      this.parseCIDR(string);\n      return true;\n    } catch (e) {\n      return false;\n    }\n  };\n\n  // A utility function to return network address given the IPv6 interface and prefix length in CIDR notation\n  ipaddr.IPv6.networkAddressFromCIDR = function (string) {\n    let cidr, i, ipInterfaceOctets, octets, subnetMaskOctets;\n    try {\n      cidr = this.parseCIDR(string);\n      ipInterfaceOctets = cidr[0].toByteArray();\n      subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();\n      octets = [];\n      i = 0;\n      while (i < 16) {\n        // Network address is bitwise AND between ip interface and mask\n        octets.push(parseInt(ipInterfaceOctets[i], 10) & parseInt(subnetMaskOctets[i], 10));\n        i++;\n      }\n      return new this(octets);\n    } catch (e) {\n      throw new Error(`ipaddr: the address does not have IPv6 CIDR format (${e})`);\n    }\n  };\n\n  // Tries to parse and validate a string with IPv6 address.\n  // Throws an error if it fails.\n  ipaddr.IPv6.parse = function (string) {\n    const addr = this.parser(string);\n    if (addr.parts === null) {\n      throw new Error('ipaddr: string is not formatted like an IPv6 Address');\n    }\n    return new this(addr.parts, addr.zoneId);\n  };\n  ipaddr.IPv6.parseCIDR = function (string) {\n    let maskLength, match, parsed;\n    if (match = string.match(/^(.+)\\/(\\d+)$/)) {\n      maskLength = parseInt(match[2]);\n      if (maskLength >= 0 && maskLength <= 128) {\n        parsed = [this.parse(match[1]), maskLength];\n        Object.defineProperty(parsed, 'toString', {\n          value: function () {\n            return this.join('/');\n          }\n        });\n        return parsed;\n      }\n    }\n    throw new Error('ipaddr: string is not formatted like an IPv6 CIDR range');\n  };\n\n  // Parse an IPv6 address.\n  ipaddr.IPv6.parser = function (string) {\n    let addr, i, match, octet, octets, zoneId;\n    if (match = string.match(ipv6Regexes.deprecatedTransitional)) {\n      return this.parser(`::ffff:${match[1]}`);\n    }\n    if (ipv6Regexes.native.test(string)) {\n      return expandIPv6(string, 8);\n    }\n    if (match = string.match(ipv6Regexes.transitional)) {\n      zoneId = match[6] || '';\n      addr = match[1];\n      if (!match[1].endsWith('::')) {\n        addr = addr.slice(0, -1);\n      }\n      addr = expandIPv6(addr + zoneId, 6);\n      if (addr.parts) {\n        octets = [parseInt(match[2]), parseInt(match[3]), parseInt(match[4]), parseInt(match[5])];\n        for (i = 0; i < octets.length; i++) {\n          octet = octets[i];\n          if (!(0 <= octet && octet <= 255)) {\n            return null;\n          }\n        }\n        addr.parts.push(octets[0] << 8 | octets[1]);\n        addr.parts.push(octets[2] << 8 | octets[3]);\n        return {\n          parts: addr.parts,\n          zoneId: addr.zoneId\n        };\n      }\n    }\n    return null;\n  };\n\n  // A utility function to return subnet mask in IPv6 format given the prefix length\n  ipaddr.IPv6.subnetMaskFromPrefixLength = function (prefix) {\n    prefix = parseInt(prefix);\n    if (prefix < 0 || prefix > 128) {\n      throw new Error('ipaddr: invalid IPv6 prefix length');\n    }\n    const octets = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n    let j = 0;\n    const filledOctetCount = Math.floor(prefix / 8);\n    while (j < filledOctetCount) {\n      octets[j] = 255;\n      j++;\n    }\n    if (filledOctetCount < 16) {\n      octets[filledOctetCount] = Math.pow(2, prefix % 8) - 1 << 8 - prefix % 8;\n    }\n    return new this(octets);\n  };\n\n  // Try to parse an array in network order (MSB first) for IPv4 and IPv6\n  ipaddr.fromByteArray = function (bytes) {\n    const length = bytes.length;\n    if (length === 4) {\n      return new ipaddr.IPv4(bytes);\n    } else if (length === 16) {\n      return new ipaddr.IPv6(bytes);\n    } else {\n      throw new Error('ipaddr: the binary input is neither an IPv6 nor IPv4 address');\n    }\n  };\n\n  // Checks if the address is valid IP address\n  ipaddr.isValid = function (string) {\n    return ipaddr.IPv6.isValid(string) || ipaddr.IPv4.isValid(string);\n  };\n\n  // Checks if the address is valid IP address in CIDR notation\n  ipaddr.isValidCIDR = function (string) {\n    return ipaddr.IPv6.isValidCIDR(string) || ipaddr.IPv4.isValidCIDR(string);\n  };\n\n  // Attempts to parse an IP Address, first through IPv6 then IPv4.\n  // Throws an error if it could not be parsed.\n  ipaddr.parse = function (string) {\n    if (ipaddr.IPv6.isValid(string)) {\n      return ipaddr.IPv6.parse(string);\n    } else if (ipaddr.IPv4.isValid(string)) {\n      return ipaddr.IPv4.parse(string);\n    } else {\n      throw new Error('ipaddr: the address has neither IPv6 nor IPv4 format');\n    }\n  };\n\n  // Attempt to parse CIDR notation, first through IPv6 then IPv4.\n  // Throws an error if it could not be parsed.\n  ipaddr.parseCIDR = function (string) {\n    try {\n      return ipaddr.IPv6.parseCIDR(string);\n    } catch (e) {\n      try {\n        return ipaddr.IPv4.parseCIDR(string);\n      } catch (e2) {\n        throw new Error('ipaddr: the address has neither IPv6 nor IPv4 CIDR format');\n      }\n    }\n  };\n\n  // Parse an address and return plain IPv4 address if it is an IPv4-mapped address\n  ipaddr.process = function (string) {\n    const addr = this.parse(string);\n    if (addr.kind() === 'ipv6' && addr.isIPv4MappedAddress()) {\n      return addr.toIPv4Address();\n    } else {\n      return addr;\n    }\n  };\n\n  // An utility function to ease named range matching. See examples below.\n  // rangeList can contain both IPv4 and IPv6 subnet entries and will not throw errors\n  // on matching IPv4 addresses to IPv6 ranges or vice versa.\n  ipaddr.subnetMatch = function (address, rangeList, defaultName) {\n    let i, rangeName, rangeSubnets, subnet;\n    if (defaultName === undefined || defaultName === null) {\n      defaultName = 'unicast';\n    }\n    for (rangeName in rangeList) {\n      if (Object.prototype.hasOwnProperty.call(rangeList, rangeName)) {\n        rangeSubnets = rangeList[rangeName];\n        // ECMA5 Array.isArray isn't available everywhere\n        if (rangeSubnets[0] && !(rangeSubnets[0] instanceof Array)) {\n          rangeSubnets = [rangeSubnets];\n        }\n        for (i = 0; i < rangeSubnets.length; i++) {\n          subnet = rangeSubnets[i];\n          if (address.kind() === subnet[0].kind() && address.match.apply(address, subnet)) {\n            return rangeName;\n          }\n        }\n      }\n    }\n    return defaultName;\n  };\n\n  // Export for both the CommonJS and browser-like environment\n  if (typeof module !== 'undefined' && module.exports) {\n    module.exports = ipaddr;\n  } else {\n    root.ipaddr = ipaddr;\n  }\n})(this);","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}