{"ast":null,"code":"const {\n  Transform\n} = require('readable-stream');\nclass Block extends Transform {\n  constructor(size, opts = {}) {\n    super(opts);\n    if (typeof size === 'object') {\n      opts = size;\n      size = opts.size;\n    }\n    this.size = size || 512;\n    const {\n      nopad,\n      zeroPadding = true\n    } = opts;\n    if (nopad) this._zeroPadding = false;else this._zeroPadding = !!zeroPadding;\n    this._buffered = [];\n    this._bufferedBytes = 0;\n  }\n  _transform(buf, enc, next) {\n    this._bufferedBytes += buf.length;\n    this._buffered.push(buf);\n    while (this._bufferedBytes >= this.size) {\n      this._bufferedBytes -= this.size;\n\n      // Assemble the buffers that will compose the final block\n      const blockBufs = [];\n      let blockBufsBytes = 0;\n      while (blockBufsBytes < this.size) {\n        const b = this._buffered.shift();\n        if (blockBufsBytes + b.length <= this.size) {\n          blockBufs.push(b);\n          blockBufsBytes += b.length;\n        } else {\n          // If the last buffer is larger than needed for the block, just\n          // use the needed part\n          const neededSize = this.size - blockBufsBytes;\n          blockBufs.push(b.slice(0, neededSize));\n          blockBufsBytes += neededSize;\n          this._buffered.unshift(b.slice(neededSize));\n        }\n      }\n\n      // Then concat just those buffers, leaving the rest untouched in _buffered\n      this.push(Buffer.concat(blockBufs, this.size));\n    }\n    next();\n  }\n  _flush() {\n    if (this._bufferedBytes && this._zeroPadding) {\n      const zeroes = Buffer.alloc(this.size - this._bufferedBytes);\n      this._buffered.push(zeroes);\n      this.push(Buffer.concat(this._buffered));\n      this._buffered = null;\n    } else if (this._bufferedBytes) {\n      this.push(Buffer.concat(this._buffered));\n      this._buffered = null;\n    }\n    this.push(null);\n  }\n}\nmodule.exports = Block;","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}