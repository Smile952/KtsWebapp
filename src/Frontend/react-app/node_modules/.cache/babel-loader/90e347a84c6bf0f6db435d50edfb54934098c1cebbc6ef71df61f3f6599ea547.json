{"ast":null,"code":"import * as React from 'react';\nimport useEventCallback from '@mui/utils/useEventCallback';\nimport useId from '@mui/utils/useId';\nimport { useUtils } from \"../useUtils.js\";\nimport { usePickerTranslations } from \"../../../hooks/index.js\";\nimport { syncSelectionToDOM } from \"./syncSelectionToDOM.js\";\n/**\n * Generate the props to pass to the content element of each section of the field.\n * It is not used by the non-accessible DOM structure (with an <input /> element for editing).\n * It should be used in the MUI accessible DOM structure and the Base UI implementation.\n * @param {UseFieldRootPropsParameters} parameters The parameters of the hook.\n * @returns {UseFieldRootPropsReturnValue} The props to forward to the content element of each section of the field.\n */\nexport function useFieldSectionContentProps(parameters) {\n  const utils = useUtils();\n  const translations = usePickerTranslations();\n  const id = useId();\n  const {\n    focused,\n    domGetters,\n    stateResponse,\n    applyCharacterEditing,\n    manager: {\n      internal_fieldValueManager: fieldValueManager\n    },\n    stateResponse: {\n      // States and derived states\n      parsedSelectedSections,\n      sectionsValueBoundaries,\n      state,\n      value,\n      // Methods to update the states\n      clearActiveSection,\n      setCharacterQuery,\n      setSelectedSections,\n      updateSectionValue,\n      updateValueFromValueStr\n    },\n    internalPropsWithDefaults: {\n      disabled = false,\n      readOnly = false\n    }\n  } = parameters;\n  const isContainerEditable = parsedSelectedSections === 'all';\n  const isEditable = !isContainerEditable && !disabled && !readOnly;\n\n  /**\n   * If a section content has been updated with a value we don't want to keep,\n   * Then we need to imperatively revert it (we can't let React do it because the value did not change in his internal representation).\n   */\n  const revertDOMSectionChange = useEventCallback(sectionIndex => {\n    if (!domGetters.isReady()) {\n      return;\n    }\n    const section = state.sections[sectionIndex];\n    domGetters.getSectionContent(sectionIndex).innerHTML = section.value || section.placeholder;\n    syncSelectionToDOM({\n      focused,\n      domGetters,\n      stateResponse\n    });\n  });\n  const handleInput = useEventCallback(event => {\n    if (!domGetters.isReady()) {\n      return;\n    }\n    const target = event.target;\n    const keyPressed = target.textContent ?? '';\n    const sectionIndex = domGetters.getSectionIndexFromDOMElement(target);\n    const section = state.sections[sectionIndex];\n    if (readOnly) {\n      revertDOMSectionChange(sectionIndex);\n      return;\n    }\n    if (keyPressed.length === 0) {\n      if (section.value === '') {\n        revertDOMSectionChange(sectionIndex);\n        return;\n      }\n      const inputType = event.nativeEvent.inputType;\n      if (inputType === 'insertParagraph' || inputType === 'insertLineBreak') {\n        revertDOMSectionChange(sectionIndex);\n        return;\n      }\n      revertDOMSectionChange(sectionIndex);\n      clearActiveSection();\n      return;\n    }\n    applyCharacterEditing({\n      keyPressed,\n      sectionIndex\n    });\n\n    // The DOM value needs to remain the one React is expecting.\n    revertDOMSectionChange(sectionIndex);\n  });\n  const handleMouseUp = useEventCallback(event => {\n    // Without this, the browser will remove the selected when clicking inside an already-selected section.\n    event.preventDefault();\n  });\n  const handlePaste = useEventCallback(event => {\n    // prevent default to avoid the input `onInput` handler being called\n    event.preventDefault();\n    if (readOnly || disabled || typeof parsedSelectedSections !== 'number') {\n      return;\n    }\n    const activeSection = state.sections[parsedSelectedSections];\n    const pastedValue = event.clipboardData.getData('text');\n    const lettersOnly = /^[a-zA-Z]+$/.test(pastedValue);\n    const digitsOnly = /^[0-9]+$/.test(pastedValue);\n    const digitsAndLetterOnly = /^(([a-zA-Z]+)|)([0-9]+)(([a-zA-Z]+)|)$/.test(pastedValue);\n    const isValidPastedValue = activeSection.contentType === 'letter' && lettersOnly || activeSection.contentType === 'digit' && digitsOnly || activeSection.contentType === 'digit-with-letter' && digitsAndLetterOnly;\n    if (isValidPastedValue) {\n      setCharacterQuery(null);\n      updateSectionValue({\n        section: activeSection,\n        newSectionValue: pastedValue,\n        shouldGoToNextSection: true\n      });\n    }\n    // If the pasted value corresponds to a single section, but not the expected type, we skip the modification\n    else if (!lettersOnly && !digitsOnly) {\n      setCharacterQuery(null);\n      updateValueFromValueStr(pastedValue);\n    }\n  });\n  const handleDragOver = useEventCallback(event => {\n    event.preventDefault();\n    event.dataTransfer.dropEffect = 'none';\n  });\n  const createFocusHandler = useEventCallback(sectionIndex => () => {\n    if (disabled) {\n      return;\n    }\n    setSelectedSections(sectionIndex);\n  });\n  return React.useCallback((section, sectionIndex) => {\n    const sectionBoundaries = sectionsValueBoundaries[section.type]({\n      currentDate: fieldValueManager.getDateFromSection(value, section),\n      contentType: section.contentType,\n      format: section.format\n    });\n    return {\n      // Event handlers\n      onInput: handleInput,\n      onPaste: handlePaste,\n      onMouseUp: handleMouseUp,\n      onDragOver: handleDragOver,\n      onFocus: createFocusHandler(sectionIndex),\n      // Aria attributes\n      'aria-labelledby': `${id}-${section.type}`,\n      'aria-readonly': readOnly,\n      'aria-valuenow': getSectionValueNow(section, utils),\n      'aria-valuemin': sectionBoundaries.minimum,\n      'aria-valuemax': sectionBoundaries.maximum,\n      'aria-valuetext': section.value ? getSectionValueText(section, utils) : translations.empty,\n      'aria-label': translations[section.type],\n      'aria-disabled': disabled,\n      // Other\n      tabIndex: isContainerEditable || sectionIndex > 0 ? -1 : 0,\n      contentEditable: !isContainerEditable && !disabled && !readOnly,\n      role: 'spinbutton',\n      id: `${id}-${section.type}`,\n      'data-range-position': section.dateName || undefined,\n      spellCheck: isEditable ? false : undefined,\n      autoCapitalize: isEditable ? 'off' : undefined,\n      autoCorrect: isEditable ? 'off' : undefined,\n      children: section.value || section.placeholder,\n      inputMode: section.contentType === 'letter' ? 'text' : 'numeric'\n    };\n  }, [sectionsValueBoundaries, id, isContainerEditable, disabled, readOnly, isEditable, translations, utils, handleInput, handlePaste, handleMouseUp, handleDragOver, createFocusHandler, fieldValueManager, value]);\n}\nfunction getSectionValueText(section, utils) {\n  if (!section.value) {\n    return undefined;\n  }\n  switch (section.type) {\n    case 'month':\n      {\n        if (section.contentType === 'digit') {\n          return utils.format(utils.setMonth(utils.date(), Number(section.value) - 1), 'month');\n        }\n        const parsedDate = utils.parse(section.value, section.format);\n        return parsedDate ? utils.format(parsedDate, 'month') : undefined;\n      }\n    case 'day':\n      return section.contentType === 'digit' ? utils.format(utils.setDate(utils.startOfYear(utils.date()), Number(section.value)), 'dayOfMonthFull') : section.value;\n    case 'weekDay':\n      // TODO: improve by providing the label of the week day\n      return undefined;\n    default:\n      return undefined;\n  }\n}\nfunction getSectionValueNow(section, utils) {\n  if (!section.value) {\n    return undefined;\n  }\n  switch (section.type) {\n    case 'weekDay':\n      {\n        if (section.contentType === 'letter') {\n          // TODO: improve by resolving the week day number from a letter week day\n          return undefined;\n        }\n        return Number(section.value);\n      }\n    case 'meridiem':\n      {\n        const parsedDate = utils.parse(`01:00 ${section.value}`, `${utils.formats.hours12h}:${utils.formats.minutes} ${section.format}`);\n        if (parsedDate) {\n          return utils.getHours(parsedDate) >= 12 ? 1 : 0;\n        }\n        return undefined;\n      }\n    case 'day':\n      return section.contentType === 'digit-with-letter' ? parseInt(section.value, 10) : Number(section.value);\n    case 'month':\n      {\n        if (section.contentType === 'digit') {\n          return Number(section.value);\n        }\n        const parsedDate = utils.parse(section.value, section.format);\n        return parsedDate ? utils.getMonth(parsedDate) + 1 : undefined;\n      }\n    default:\n      return section.contentType !== 'letter' ? Number(section.value) : undefined;\n  }\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}